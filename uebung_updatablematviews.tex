\documentclass[11pt,a4paper,parskip=half]{scrartcl}
\usepackage{ngerman}
\usepackage[utf8]{inputenc}
\usepackage[colorlinks=false,pdfborder={0 0 0}]{hyperref}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{longtable}
\usepackage{float}
\usepackage{textcomp}
\usepackage{geometry}
\usepackage{listings}
 \usepackage{german}
\geometry{a4paper, left=30mm, right=25mm, top=30mm, bottom=35mm} 
\usepackage{listings}
\lstset{breaklines=true, breakatwhitespace=true, basicstyle=\scriptsize, numbers=left}
\title{mvdbs: Updatable Materialized View}
\author{Tobias Lerch, Yanick Eberle, Pascal Schwarz}
\begin{document}
\maketitle

\section{Einleitung}
Ihre Lösung muss aus folgenden Teilen bestehen:\\
• Eine Beschreibung Ihrer Szenarios --> meinsch da esch guet so?

In dieser Übung geht es darum, eine Replikation einzurichten und anschliessend die Auswirkungen und das Verhalten der Replikation genauer unter die Lupe zu nehmen.

Wir erstellen auf dem Telesto Server eine Master Group und definieren die Relation Filialen als Replikationsobjekt, welche anschliessend der Master Group hinzugefügt wird. Um dieses anschliessend replizieren zu können, müssen noch Trigger und Packages erstellt werden und alles muss in den Replikationsprozess aufgenommen werden.

Als Gegenstück zur Master Group auf Telesto erstellen wir auf auf dem Ganymed Server eine Materialized View Group, in welche ebenfalls die Relation Filiale als Replikationsobjekt aufgenommen wird. Anschliessend definieren eine Refresh Gruppe und fügen die Materialized View hinzu,  damit die Änderungen auch repliziert werden.

Soblad alles eingerichtet ist, werden die Tests ausgeführt und analysiert.

\section{Replikation einrichten}
Die Master Site und die Materialized View Site wurde bereits eingerichtet, somit müssen nur noch die jeweiligen Gruppen erstellt werden.
\subsection{Erstellen der Master Group}
Wir verbinden uns als Benutzer repadmin auf den Telesto Server und führen folgende SQL Statements aus.\\

\lstinputlisting{SQLStatements/01_master_group.txt} 
Das Resultat des SQL Developers ist ein einfaches  \glqq anonymer Block abgeschlossen\grqq. Somit ist die Master Gruppe erstellt.\\

\lstinputlisting{SQLStatements/02_master_repobj.txt}
Die Relation Filialen ist nun ein Replikationsobjekt  und wird der Master Gruppe hinzugefügt. \\

\lstinputlisting{SQLStatements/03_rep_support.txt}
Dieses Statement erstellt die Trigger und Packages, welche für die Replikation gebraucht werden.\\

\lstinputlisting{SQLStatements/04_resume_master.txt}
Die Änderungen werden in den Replikationsprozess aufgenommen.\\

\subsection{Erstellen der Materialized View Group}
Wir verbinden uns als Benutzer mvdbs10 auf den Telesto Server und führen folgende SQL Statements aus.\\

\lstinputlisting{SQLStatements/05_matView.txt}
Auf Telesto wurde nun die Materialized View erstellt und mit \glqq materialized view LOG erstellt.\grqq bestätigt.\\

\lstinputlisting{SQLStatements/06_DBLink.txt}
Der Database Link wird als Benutzer mvdbs10 auf dem Server ganymed erstellt.\\

\lstinputlisting{SQLStatements/07_mview_repgrp.txt}
Dieses Statement erstellt eine neue Materialized View Group.\\

\lstinputlisting{SQLStatements/08_refresh.txt}
Es wird eine Refresh Gruppe erstellt, welche einen stündlichen refresh definiert.\\

\lstinputlisting{SQLStatements/09_mview.txt}
Als Benutzer mvdbs10 auf dem Server ganymed wird die Materialized View erstellt.\\

\lstinputlisting{SQLStatements/10_mview_repobj.txt}
Als Benutzer mviewadmin auf ganymed wird die Relation Filialen als Replikationsobjekt zu der Materialized View Group hinzugefügt.\\

\lstinputlisting{SQLStatements/11_refresh.txt}
Die Materialized View wird zur Refresh Grupppe hinzugefügt.\\

\lstinputlisting{SQLStatements/12_demand_refresh.txt}
Mit diesem Statement kann der Refresh direkt ausgeführt werden.\\

\section{Testszenarien}
\subsection{Ohne Konflikt}
\subsubsection{updates}
Um zu überprüfen, ob updates korrekt repliziert werden, erstellen wir ein Query für die Master Site und ein zweites Query für die Materialized View Site, wobei diese unterschiedliche Daten verändern. Dabei sollte kein Konflikt auftreten. Nach der Replikation sollte die Tabelle Filiale auf beiden Sites identisch sein.

Folgendes Query wird auf der Master Site ausgeführt (ab Zeile 5 Output):
\begin{lstlisting}
UPDATE filialen
SET ort='Brugg'
WHERE ort='Basel' and fnr='F4'; 

1 Zeilen aktualisiert.
\end{lstlisting}

Auf der Materialized View Site erstellen wir ebenfalls ein Query (ab Zeile 5 Output):
\begin{lstlisting}
UPDATE filialen
SET ort='Brugg'
WHERE ort='Basel' and fnr='F1'; 

1 Zeilen aktualisiert.
\end{lstlisting}

Nun untersuchen wir die beiden Logs.

Nach der Ausführung des Querys auf der Master Site sehen wir mit folgendem Befehl die Einträge im Log:
\begin{lstlisting}
SELECT * FROM MLOG$_FILIALEN ;
\end{lstlisting}

Im Log auf der Master Site ist ersichtlich, dass sich der Eintrag mit dem Primary Key FNR F4 geändert hat. Ebenfalls wurde eine CHANGE\_VECTOR und eine XID generiert, welche anschliessend für die Replikation verwendet wird.  Der Zeitstempel bei SNAPTIME ist noch mit dem Default Wert abgefüllt. Es wird nur verwendet, wenn mehrere Snapshots auf einem Master definier sind. Da wir nur eine Materialized View haben, wird dieses Feld nicht verwendet. Der Eintrag 'U' unter DMLTYPE und  OLD\_NEW zeigt, dass es sich bei der Änderung um ein Update handelt.
\begin{lstlisting}
FNR SNAPTIME$$ DMLTYPE$$ OLD_NEW$$ CHANGE_VECTOR$$ XID$$
--- ---------- --------- --------- --------------- ----------
F4  01.01.00   U         U         04              1.7E+15 
\end{lstlisting}

Auch auf der Materialized View Site kann nach dem Ausführen des Querys das Log eingesehen werden:
\begin{lstlisting}
SELECT * FROM USLOG$_FILIALEN ;
\end{lstlisting}

Hier ist im Log ersichtlich, dass sich der Eintrag mit dem Primary Key FNR F1 geändert hat. Auf der Materialized View Site wird kein CHANGE\_VECTOR und XID generiert.
\begin{lstlisting}
FNR SNAPTIME$$ DMLTYPE$$ OLD_NEW$$
--- ---------- --------- ---------
F1  01.01.00   U         U         
\end{lstlisting}

Wir geben die Änderungen für die Replikation frei, indem wir auf beiden Sites ein commit ausführen (ab Zeile 3 Output):
\begin{lstlisting}
COMMIT

festgeschrieben.
\end{lstlisting}

Nachdem die Replikation durchgeführt wurde, betrachten wir die Logs erneut.

Der Eintrag im Log ist verschwunden. Das heisst, die Einträge bleiben nur gespeichert, bis die Replikation durchgeführt wurde. Jede Zeile im Log bedeutet, dass eine Zeile geändert wurde und repliziert werden muss. Bei der Replikation kann mithilfe des Logs die Änderung auf der Materialized View vorgenommen werden.
\begin{lstlisting}
Keine Zeilen gewaehlt
\end{lstlisting}

Das gleiche gilt für das Log auf der Materialized View Site.
\begin{lstlisting}
Keine Zeilen gewaehlt
\end{lstlisting}

\subsubsection{inserts}
Um zu überprüfen, ob inserts korrekt repliziert werden, erstellen wir ein Query für die Master Site und ein zweites Query für die Materialized View Site, wobei diese unterschiedliche Daten einfügt. Dabei sollte kein Konflikt auftreten. Nach der Replikation sollte die Tabelle Filiale auf beiden Sites identisch sein.

Folgendes Query wird auf der Master Site ausgeführt (ab Zeile 3 Output):
\begin{lstlisting}
INSERT INTO filialen (fnr, ort, plz) values ('F5', 'Genf', 9000);

1 Zeilen eingefuegt.
\end{lstlisting}

Auf der Materialized View Site erstellen wir ebenfalls ein Query (ab Zeile 3 Output):
\begin{lstlisting}
INSERT INTO filialen (fnr, ort, plz) values ('F6', 'Genf', 9000);

1 Zeilen eingefuegt.
\end{lstlisting}

Nun untersuchen wir die beiden Logs.

Nach der Ausführung des Querys auf der Master Site sehen wir mit folgendem Befehl die Einträge im Log:
\begin{lstlisting}
SELECT * FROM MLOG$_FILIALEN ;
\end{lstlisting}

Wir sehen dass der Eintrag mit dem Primary Key F5 geändert wurde. Das I bei DMLTYPE steht für insert. Der Wert N bei OLD\_NEW bedeutet, es ist ein neuer Wert dazugekommen. Wiederum wurde ein CHANGE\_VECTOR und eine XID generiert.
\begin{lstlisting}
FNR SNAPTIME$$ DMLTYPE$$ OLD_NEW$$ CHANGE_VECTOR$$ XID$$
--- ---------- --------- --------- --------------- ----------
F5  01.01.00   I         N         FE              2.5E+15 
\end{lstlisting}

Auch auf der Materialized View Site kann nach dem Ausführen des Querys das Log eingesehen werden:
\begin{lstlisting}
SELECT * FROM USLOG$_FILIALEN ;
\end{lstlisting}

Hier ist im Log ersichtlich, dass sich der Eintrag mit dem Primary Key FNR F6 geändert hat. Es handelt sich ebenfalls um ein Insert.
\begin{lstlisting}
FNR SNAPTIME$$ DMLTYPE$$ OLD_NEW$$
--- ---------- --------- ---------
F6  01.01.00   I         N         
\end{lstlisting}

Wir geben die Änderungen für die Replikation frei, indem wir auf beiden Sites ein commit ausführen (ab Zeile 3 Output):
\begin{lstlisting}
COMMIT

festgeschrieben.
\end{lstlisting}

Wie bereits beim Update beschrieben ist nach der Replikation nichts mehr im Log.
\begin{lstlisting}
Keine Zeilen gewaehlt
\end{lstlisting}

\subsubsection{deletes}
Um zu überprüfen, ob deletes korrekt repliziert werden, erstellen wir ein Query für die Master Site und ein zweites Query für die Materialized View Site, wobei diese unterschiedliche Daten löschen. Dabei sollte kein Konflikt auftreten. Nach der Replikation sollte die Tabelle Filiale auf beiden Sites identisch sein.

Folgendes Query wird auf der Master Site ausgeführt (ab Zeile 5 Output):
\begin{lstlisting}
DELETE FROM filialen
WHERE ort='Genf' and fnr='F5'; 

\end{lstlisting}

Auf der Materialized View Site erstellen wir ebenfalls ein Query (ab Zeile 5 Output):
\begin{lstlisting}
DELETE FROM filialen
WHERE ort='Genf' and fnr='F6'; 

\end{lstlisting}

Nun untersuchen wir die beiden Logs.

Nach der Ausführung des Querys auf der Master Site sehen wir mit folgendem Befehl die Einträge im Log:
\begin{lstlisting}
SELECT * FROM MLOG$_FILIALEN ;
\end{lstlisting}

Wir sehen, dass der Eintrag mit dem Primary Key F5 geändert wurde. Das D bei DMLTYPE steht für delete. Der Wert O bei OLD\_NEW bedeutet, es wurde ein alter Wert gelöscht. Wiederum wurde ein CHANGE\_VECTOR und eine XID generiert.
\begin{lstlisting}
FNR SNAPTIME$$ DMLTYPE$$ OLD_NEW$$ CHANGE_VECTOR$$ XID$$
--- ---------- --------- --------- --------------- ----------
F5  01.01.00   D         O         00             2.0E+15 
\end{lstlisting}

Auch auf der Materialized View Site kann nach dem Ausführen des Querys das Log eingesehen werden:
\begin{lstlisting}
SELECT * FROM USLOG$_FILIALEN ;
\end{lstlisting}

Hier ist im Log ersichtlich, dass sich der Eintrag mit dem Primary Key FNR F6 geändert hat. Es handelt sich ebenfalls um ein Delete.
\begin{lstlisting}
FNR SNAPTIME$$ DMLTYPE$$ OLD_NEW$$
--- ---------- --------- ---------
F6  01.01.00   D         O         
\end{lstlisting}

Wir geben die Änderungen für die Replikation frei, indem wir auf beiden Sites ein commit ausführen (ab Zeile 3 Output):
\begin{lstlisting}
COMMIT

festgeschrieben.
\end{lstlisting}

Wie bereits beim Update beschrieben ist nach der Replikation nichts mehr im Log.
\begin{lstlisting}
Keine Zeilen gewaehlt
\end{lstlisting}

\subsection{Mit Konflikt}
\subsubsection{updates}
Um herauszufinden, wie sich die Replikation verhält wenn Konflikte auftreten, erstellen wir für beide Sites dasselbe SQL Query, welches dieselben Zeilen und dieselben Werte verändern. Bei der Replikation sollte ein Konflikt auftreten.

SQL Query Master Site und Materialized View (ab Zeile 5 Output):
\begin{lstlisting}
UPDATE filialen
SET ort='Brugg'
WHERE fnr='F1'; 

1 Zeilen aktualisiert.
\end{lstlisting}

Nun steht in beiden Logs dasselbe.

Die Zeile mit dem Primary Key F1 wurde geändert mit einem Update.
\begin{lstlisting}
FNR SNAPTIME$$ DMLTYPE$$ OLD_NEW$$ CHANGE_VECTOR$$ XID$$
--- ---------- --------- --------- --------------- ----------
F1  01.01.00   U         U         04             3.1E+15 
\end{lstlisting}
\begin{lstlisting}
FNR SNAPTIME$$ DMLTYPE$$ OLD_NEW$$
--- ---------- --------- ---------
F1  01.01.00   U         U         
\end{lstlisting}

Wiederum geben wir die Änderungen für die Replikation frei:
\begin{lstlisting}
COMMIT

festgeschrieben.
\end{lstlisting}

Wenn wir nun die Replikation manuell starten, erhalten wir folgende Meldung:
\begin{lstlisting}
Fehlerbericht:
ORA-23402: Wegen Konflikten bei verzoegerten Transaktionen wurde die Aktualisierung abgebrochen
ORA-06512: in "SYS.DBMS_SNAPSHOT", Zeile 2558
ORA-06512: in "SYS.DBMS_SNAPSHOT", Zeile 2771
ORA-06512: in "SYS.DBMS_IREFRESH", Zeile 685
ORA-06512: in "SYS.DBMS_REFRESH", Zeile 195
ORA-06512: in Zeile 2
23402. 00000 -  "refresh was aborted because of conflicts caused by deferred txns"
*Cause:    There are outstanding conflicts logged in the DefError table
           at the materialized view's master.
*Action:   Resolve the conflicts in the master DefError table and
           refresh again after the table is empty.  Alternatively,
           refresh with refresh_after_errors set to TRUE, which
           will proceed with the refresh even if there are conflicts
           in the master's DefError table.  Proceeding despite conflicts
           can result with an updatable materialized view's changes appearing
           to be temporarily lost (until a refresh succeeds after the
           conflicts are resolved).
\end{lstlisting}

Wir schauen uns nun die Tabelle DefErrors genauer an:
\begin{lstlisting}
SELECT * FROM DefError
\end{lstlisting}

Wir können erkennen, dass ein Konflikt zwischen Ganymed und Telesto vorhanden ist, welcher am 28.04.2013 erzeugt wurde. Ebenfalls sieht man die Fehler Nummer und die Fehlermeldung. (leider ist die Darstellung nicht überschtlich, da die Zeile zu breit ist)
\begin{lstlisting}
DEFERRED_TRAN_ID ORIGIN_TRAN_DB ORIGIN_TRAN_ID CALLNO DESTINATION START_TIME ERROR_NUMBER ERROR_MSG  RECEIVER
---------------- -------------- ------------ ------- ------------ -------------- ----------- ----------- ----------
8.4.89471   GANYMED.SIRIUS.FHNW.CH  7.31.97249  0 TELESTO.JANUS.FHNW.CH   28.04.13  100 ORA-01403: Keine Daten gefunden  REPADMIN
\end{lstlisting}

Da wir später eine Regel zur Konfliktauflösung definieren, brechen wir hier ab. Wir haben gesehen, dass ein Konflikt auftritt.
\subsubsection{inserts}
Um herauszufinden, wie sich die Replikation verhält wenn Konflikte auftreten, erstellen wir für beide Sites dasselbe SQL Query, welches dieselben Zeilen und dieselben Werte einfügt. Bei der Replikation sollte ein Konflikt auftreten.

SQL Query Master Site und Materialized View (ab Zeile 3 Output):
\begin{lstlisting}
INSERT INTO filialen (fnr, ort, plz) values ('F6', 'Genf', 9000);

1 Zeilen eingefuegt.
\end{lstlisting}

Nun steht in beiden Logs dasselbe.

Die Zeile mit dem Primary Key F6 wurde geändert mit einem Insert und neuen Werten.
\begin{lstlisting}
FNR SNAPTIME$$ DMLTYPE$$ OLD_NEW$$ CHANGE_VECTOR$$ XID$$
--- ---------- --------- --------- --------------- ----------
F6  01.01.00   I         N         FE             3.1E+15
\end{lstlisting}
\begin{lstlisting}
FNR SNAPTIME$$ DMLTYPE$$ OLD_NEW$$
--- ---------- --------- ---------
F6  01.01.00   I         N         
\end{lstlisting}

Wiederum geben wir die Änderungen für die Replikation frei:
\begin{lstlisting}
COMMIT

festgeschrieben.
\end{lstlisting}

Wenn wir nun die Replikation manuell starten, erhalten wir folgende Meldung:
\begin{lstlisting}
Fehlerbericht:
ORA-23402: Wegen Konflikten bei verzoegerten Transaktionen wurde die Aktualisierung abgebrochen
ORA-06512: in "SYS.DBMS_SNAPSHOT", Zeile 2558
ORA-06512: in "SYS.DBMS_SNAPSHOT", Zeile 2771
ORA-06512: in "SYS.DBMS_IREFRESH", Zeile 685
ORA-06512: in "SYS.DBMS_REFRESH", Zeile 195
ORA-06512: in Zeile 2
23402. 00000 -  "refresh was aborted because of conflicts caused by deferred txns"
*Cause:    There are outstanding conflicts logged in the DefError table
           at the materialized view's master.
*Action:   Resolve the conflicts in the master DefError table and
           refresh again after the table is empty.  Alternatively,
           refresh with refresh_after_errors set to TRUE, which
           will proceed with the refresh even if there are conflicts
           in the master's DefError table.  Proceeding despite conflicts
           can result with an updatable materialized view's changes appearing
           to be temporarily lost (until a refresh succeeds after the
           conflicts are resolved).
\end{lstlisting}

Hier geschiet also genau dasselbe, weil beide eine Zeile mit demselben Primary Key einfügen wollen. Auch hier betrachten wir den Eintrag in der DefError Tabelle. Es ist ersichtlich, dass der Konflikt auftritt, weil ein Constraint verletzt wurde.
\begin{lstlisting}
DEFERRED_TRAN_ID ORIGIN_TRAN_DB ORIGIN_TRAN_ID CALLNO DESTINATION START_TIME ERROR_NUMBER ERROR_MSG  RECEIVER
---------------- -------------- ------------ ------- ------------ -------------- ----------- ----------- ----------
2.11.89518   GANYMED.SIRIUS.FHNW.CH  2.7.120248  0 TELESTO.JANUS.FHNW.CH   28.04.13 -1 ORA-00001: Unique Constraint (MVDBS10.FL_PK) verletzt  REPADMIN
\end{lstlisting}

Da wir später eine Regel zur Konfliktauflösung definieren, brechen wir hier ab. Wir haben gesehen, dass ein Konflikt auftritt.
\subsubsection{deletes}
Um herauszufinden, wie sich die Replikation verhält wenn Konflikte auftreten, erstellen wir für beide Sites dasselbe SQL Query, welches dieselbe Zeile und dieselben Werte löscht. Bei der Replikation sollte ein Konflikt auftreten.

SQL Query Master Site und Materialized View (ab Zeile 4 Output):
\begin{lstlisting}
DELETE FROM filialen
WHERE ort='Genf' and fnr='F6'; 

1 Zeilen geloescht.
\end{lstlisting}

Nun steht in beiden Logs dasselbe.

Die Zeile mit dem Primary Key F6 wurde geändert mit einem Insert und neuen Werten.
\begin{lstlisting}
FNR SNAPTIME$$ DMLTYPE$$ OLD_NEW$$ CHANGE_VECTOR$$ XID$$
--- ---------- --------- --------- --------------- ----------
F6  01.01.00   D         O         00             3.1E+15 
\end{lstlisting}
\begin{lstlisting}
FNR SNAPTIME$$ DMLTYPE$$ OLD_NEW$$
--- ---------- --------- ---------
F6  01.01.00   D         O         
\end{lstlisting}

Wiederum geben wir die Änderungen für die Replikation frei:
\begin{lstlisting}
COMMIT

festgeschrieben.
\end{lstlisting}

Wenn wir nun die Replikation manuell starten, erhalten wir folgende Meldung:
\begin{lstlisting}
Fehlerbericht:
ORA-23402: Wegen Konflikten bei verzoegerten Transaktionen wurde die Aktualisierung abgebrochen
ORA-06512: in "SYS.DBMS_SNAPSHOT", Zeile 2558
ORA-06512: in "SYS.DBMS_SNAPSHOT", Zeile 2771
ORA-06512: in "SYS.DBMS_IREFRESH", Zeile 685
ORA-06512: in "SYS.DBMS_REFRESH", Zeile 195
ORA-06512: in Zeile 2
23402. 00000 -  "refresh was aborted because of conflicts caused by deferred txns"
*Cause:    There are outstanding conflicts logged in the DefError table
           at the materialized view's master.
*Action:   Resolve the conflicts in the master DefError table and
           refresh again after the table is empty.  Alternatively,
           refresh with refresh_after_errors set to TRUE, which
           will proceed with the refresh even if there are conflicts
           in the master's DefError table.  Proceeding despite conflicts
           can result with an updatable materialized view's changes appearing
           to be temporarily lost (until a refresh succeeds after the
           conflicts are resolved).
\end{lstlisting}

Hier geschiet also genau dasselbe, weil beide eine Zeile mit demselben Primary Key löschen wollen. Auch hier betrachten wir den Eintrag in der DefError Tabelle. Es ist ersichtlich, dass der Konflikt auftritt, weil ein Constraint verletzt wurde.
\begin{lstlisting}
DEFERRED_TRAN_ID ORIGIN_TRAN_DB ORIGIN_TRAN_ID CALLNO DESTINATION START_TIME ERROR_NUMBER ERROR_MSG  RECEIVER
---------------- -------------- ------------ ------- ------------ -------------- ----------- ----------- ----------
2.11.89518   GANYMED.SIRIUS.FHNW.CH  2.7.120248  0 TELESTO.JANUS.FHNW.CH   28.04.13 -1 ORA-00001: Unique Constraint (MVDBS10.FL_PK) verletzt  REPADMIN
\end{lstlisting}

Da wir später eine Regel zur Konfliktauflösung definieren, brechen wir hier ab. Wir haben gesehen, dass ein Konflikt auftritt.

\subsection{Regel zur Konfliktauflösung}
Wir verbinden uns mit dem repadmin auf den Telesto Server und führen folgende Skripts aus, um die Konfliktauflösung Overwrite zu aktivieren. Quelle: \url{http://docs.oracle.com/cd/B28359_01/server.111/b28327/rarconflictres.htm}

Zuerst müssen wir die Replikationsgruppe inaktiv setzen, damit wir Änderungen vornehmen können an der Konfiguration.
\begin{lstlisting}
BEGIN
   DBMS_REPCAT.SUSPEND_MASTER_ACTIVITY (
      gname => 'mvdbs10_repg');
END;
\end{lstlisting}

Anschliessend müssen wir eine Column Group erstellen, da wir diese benötigen um das Overwrite zu aktivieren
\begin{lstlisting}
BEGIN
   DBMS_REPCAT.MAKE_COLUMN_GROUP (
      sname => 'mvdbs10',
      oname => 'filialen',
      column_group => 'dep_cg',
      list_of_column_names => 'fnr');
END;
\end{lstlisting}

Nun können wir die Konfliktauflösung definieren. Wir erstellen eine Overwrite Konfliktauflösung.
\begin{lstlisting}
BEGIN
   DBMS_REPCAT.ADD_UPDATE_RESOLUTION (
      sname => 'mvdbs10',
      oname => 'filialen',
      column_group => 'dep_cg',
      sequence_no => 1,
      method => 'DISCARD',
      parameter_column_name => 'manager_id,location_id');
END;
\end{lstlisting}

Nun müssen wir den Replikationssupport neu generieren.
\begin{lstlisting}
BEGIN 
    DBMS_REPCAT.GENERATE_REPLICATION_SUPPORT (
      sname => 'mvdbs10',
      oname => 'filialen', 
      type => 'TABLE',
      min_communication => TRUE); 
END;
\end{lstlisting}

Und zuletzt muss die Replikationsgruppe wieder aktiviert werden.
\begin{lstlisting}
BEGIN
   DBMS_REPCAT.RESUME_MASTER_ACTIVITY (
      gname => 'mvdbs10_repg');
END;
\end{lstlisting}

\subsection{Mit Konflikt und Konfliktauflösung}
\subsubsection{updates}
Wir machen genau dasselbe wie oben mit Konflikt.

Wenn wir nun die Replikation manuell starten, erhalten wir folgende Meldung:
\begin{lstlisting}
\end{lstlisting}
\subsubsection{inserts}
Wir machen genau dasselbe wie oben mit Konflikt.

Wenn wir nun die Replikation manuell starten, erhalten wir folgende Meldung:
\begin{lstlisting}
\end{lstlisting}
\subsubsection{deletes}
Wir machen genau dasselbe wie oben mit Konflikt.

Wenn wir nun die Replikation manuell starten, erhalten wir folgende Meldung:
\begin{lstlisting}
\end{lstlisting}
\end{document}